% Fun with Transactions
\documentclass{beamer}
\usetheme{Ilmenau}
%\usepackage{tipa}
\usepackage{color}
\usepackage{listings}
\usepackage[utf8,latin9]{inputenc}
\usepackage[T1]{fontenc}
%\usepackage{babel}
\beamertemplatenavigationsymbolsempty

\begin{document}
\title{Fun with Transactions}
% subtitle: what robust transactions can do for you, and how they can do it for free
\author{Joshua Tolley -- eggyknap -- End Point Corporation}

% outline:
% introductory blabber
% What's a transaction?
% - Classic banking example
% - More commonplace example (i.e. everyone knows financials need to be robust; what about other stuff)
% How do you implement such things
% - WAL log
% - Locking & MVCC (explain vacuum)
% - Explain clog, xmin, xmax? Too much detail?
% Visibility
% - dirty, phantom, and non-repeatable reads. Isolation levels
% Go back to examples for a while to emphasize why it's important to have transactions
% - You need transactions whether you're ready to admit it or not
% - The application has units of work it needs to keep atomic. What's more, only the application knows the boundaries of those units
% - Unfortunately often your ORM disagrees with these last two
% - Lots of programmers are too lazy to catch and handle transaction errors (e.g. locking failures, serialization failures)
% - Some people understand transactions' importance enough to transaction-enable other stuff. Message queues, data transformation services
% Multiple transactional systems can coordinate via 2PC
% - Java has the XA spec, and transaction managers. Federation software is also a possibility
% - There aren't many non-Java transaction managers
% - You can have one (but not more) non-2PC capable devices in a commit group, if it's done right
% Problems with pathological behavior
% - Locking tons of stuff
% - Long transactions are bad, and not just because of PostgreSQL and vacuum
% - Serialization failures
% What to do about it all?... 

% A story:

% Alice is building a web application to sell widgets, and needs a database. Part
% of the database needs to store customer names. Her database has data types for
% "text", and length-constrained "varchar". She prefers a length constraint,
% because she's heard TEXT can be slow, and she doesn't want people to enter a 2
% GB name anyway. She doesn't know how big to make it, but she figures it has to
% be a power of two, because that seems like what everyone does. So how about 64
% characters? Or should it be a power of two minus one? 63? Ok, so customer_name
% VARCHAR(63). This is all fine and good, but how did we choose that limit? Oh,
% right, it was fairly random. Do the developers know about it? Erm... So if
% something fails because a user actually entered a 2 GB name, will the code
% notice?
%
%Note:
%PostgreSQL's tendency to yell when you freak out a transaction, and keep
%yelling, is a good thing. That makes it harder for bad programmers to fail to
%note they've had an error. It means once something has gone wrong, and part of
%the transaction has failed, it means the rest of the transaction will always
%fail It means once something has gone wrong, and part of teh transaction has
%failed, it means the rest of the transaction will always fail. Whcih is the
%point of transactions
%
%Ok, now I have some database constraints, which means I'm Doing It Right. 
%But if you don't have all this in a strict transaction, you'll have some of the
%data commit, and some of it not commit. 
%
%Users can sometimes figure out when stuff like this happens, and deal with the
%results, but this gets particularly irritating when the new Management
%Consultant comes in with a report that the automated web app testing service
%isn't getting repeatable results.

\end{document}
